import{_ as s,c as a,o as e,b as l}from"./app.2e15d874.js";const t="/docs/assets/image-20210825003056359.8fd9a4e8.png",b=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[{"level":2,"title":"请说说MyBatis的工作原理","slug":"请说说mybatis的工作原理","link":"#请说说mybatis的工作原理","children":[]},{"level":2,"title":"Mybatis是否支持延迟加载？如果支持，它的实现原理是什么？","slug":"mybatis是否支持延迟加载-如果支持-它的实现原理是什么","link":"#mybatis是否支持延迟加载-如果支持-它的实现原理是什么","children":[]},{"level":2,"title":"#{}和${}的区别","slug":"和-的区别","link":"#和-的区别","children":[]},{"level":2,"title":"在mapper中如何传递多个参数","slug":"在mapper中如何传递多个参数","link":"#在mapper中如何传递多个参数","children":[]},{"level":2,"title":"foreach表情有哪些属性","slug":"foreach表情有哪些属性","link":"#foreach表情有哪些属性","children":[]},{"level":2,"title":"如何获取生成的主键","slug":"如何获取生成的主键","link":"#如何获取生成的主键","children":[]},{"level":2,"title":"当实体类中的属性名和表中的字段名不一样 ，怎么办","slug":"当实体类中的属性名和表中的字段名不一样-怎么办","link":"#当实体类中的属性名和表中的字段名不一样-怎么办","children":[]},{"level":2,"title":"使用MyBatis的mapper接口调用时有哪些要求？","slug":"使用mybatis的mapper接口调用时有哪些要求","link":"#使用mybatis的mapper接口调用时有哪些要求","children":[]},{"level":2,"title":"Dao接口里的方法，参数不同 时，方法能重载吗","slug":"dao接口里的方法-参数不同-时-方法能重载吗","link":"#dao接口里的方法-参数不同-时-方法能重载吗","children":[]},{"level":2,"title":"Mybatis动态sql是做什么的？都有哪些动态sql？能简述一下动 态sql的执行原理吗？","slug":"mybatis动态sql是做什么的-都有哪些动态sql-能简述一下动-态sql的执行原理吗","link":"#mybatis动态sql是做什么的-都有哪些动态sql-能简述一下动-态sql的执行原理吗","children":[]},{"level":2,"title":"Mybatis是如何进行分页的？分页插件的原理是什么？","slug":"mybatis是如何进行分页的-分页插件的原理是什么","link":"#mybatis是如何进行分页的-分页插件的原理是什么","children":[]},{"level":2,"title":"简述Mybatis的插件运行原理，以及如何编写一个插件。","slug":"简述mybatis的插件运行原理-以及如何编写一个插件。","link":"#简述mybatis的插件运行原理-以及如何编写一个插件。","children":[]},{"level":2,"title":"Mybatis的一级、二级缓存","slug":"mybatis的一级、二级缓存","link":"#mybatis的一级、二级缓存","children":[]}],"relativePath":"zh/java/面试/SSM框架/Mybatis框架.md","lastUpdated":1675892686000}'),n={name:"zh/java/面试/SSM框架/Mybatis框架.md"},i=l('<h2 id="请说说mybatis的工作原理" tabindex="-1">请说说MyBatis的工作原理 <a class="header-anchor" href="#请说说mybatis的工作原理" aria-hidden="true">#</a></h2><p><img src="'+t+`" alt="image-20210825003056359"></p><ol><li><p>读取 MyBatis 配置文件：mybatis-config.xml 为 MyBatis 的全局配置文件，配置了 MyBatis 的运 行环境等信息，例如数据库连接信息。</p></li><li><p>加载映射文件。映射文件即 SQL 映射文件，该文件中配置了操作数据库的 SQL 语句，需要在 MyBatis 配置文件 mybatis-config.xml 中加载。mybatis-config.xml 文件可以加载多个映射文 件，每个文件对应数据库中的一张表。</p></li><li><p>构造会话工厂：通过 MyBatis 的环境等配置信息构建会话工厂 SqlSessionFactory。</p></li><li><p>创建会话对象：由会话工厂创建 SqlSession 对象，该对象中包含了执行 SQL 语句的所有方法。</p></li><li><p>Executor 执行器：MyBatis 底层定义了一个 Executor 接口来操作数据库，它将根据 SqlSession 传递的参数动态地生成需要执行的 SQL 语句，同时负责查询缓存的维护。</p></li><li><p>MappedStatement 对象：在 Executor 接口的执行方法中有一个 MappedStatement 类型的参 数，该参数是对映射信息的封装，用于存储要映射的 SQL 语句的 id、参数等信息。 update user set name = lis where id = ?</p></li><li><p>输入参数映射：输入参数类型可以是 Map、List 等集合类型，也可以是基本数据类型和 POJO 类 型。输入参数映射过程类似于 JDBC 对 preparedStatement 对象设置参数的过程。</p></li><li><p>输出结果映射：输出结果类型可以是 Map、 List 等集合类型，也可以是基本数据类型和 POJO 类 型。输出结果映射过程类似于 JDBC 对结果集的解析过程。</p></li></ol><h2 id="mybatis是否支持延迟加载-如果支持-它的实现原理是什么" tabindex="-1">Mybatis是否支持延迟加载？如果支持，它的实现原理是什么？ <a class="header-anchor" href="#mybatis是否支持延迟加载-如果支持-它的实现原理是什么" aria-hidden="true">#</a></h2><p>Mybatis仅支持association关联对象和collection关联集合对象的延迟加载，association指的就是 一对一，collection指的就是一对多查询。在Mybatis配置文件中，可以配置是否启用延迟加载 lazyLoadingEnabled=true|false。</p><p>它的原理是，使用CGLIB创建目标对象的代理对象，当调用目标方法时，进入拦截器方法，比如调 a.getB().getName()，拦截器invoke()方法发现a.getB()是null值，那么就会单独发送事先保存好的查询关联B对象的sql，把B查询上来，然后调用a.setB(b)，于是a的对象b属性就有值了，接着完 成a.getB().getName()方法的调用。这就是延迟加载的基本原理。</p><h2 id="和-的区别" tabindex="-1">#{}和\${}的区别 <a class="header-anchor" href="#和-的区别" aria-hidden="true">#</a></h2><p>#{}是占位符，预编译处理；\${}是拼接符，字符串替换，没有预编译处理。</p><p>Mybatis在处理#{}时，#{}传入参数是以字符串传入，会将SQL中的#{}替换为?号，调用 PreparedStatement的set方法来赋值。</p><p>#{} 可以有效的防止SQL注入，提高系统安全性；\${} 不能防止SQL 注入</p><p>#{} 的变量替换是在数据库系统中； \${} 的变量替换是在 数据库系统外</p><h2 id="在mapper中如何传递多个参数" tabindex="-1">在mapper中如何传递多个参数 <a class="header-anchor" href="#在mapper中如何传递多个参数" aria-hidden="true">#</a></h2><p><strong>方法1：顺序传参法</strong></p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">public User selectUser(String name, int deptId);</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">&lt;select id=&quot;selectUser&quot; resultMap=&quot;UserResultMap&quot;&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;">	select * from user where user_name = #{arg0} and dept_id = #{arg1}</span></span>
<span class="line"><span style="color:#A6ACCD;">&lt;/select&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre></div><p>#{}里面的数字代表传入参数的顺序。</p><p><strong>方法2：@Param注解传参法</strong></p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">public User selectUser(@Param(&quot;userName&quot;) String name,  @Param(&quot;deptId&quot;) int deptId);</span></span>
<span class="line"><span style="color:#A6ACCD;">&lt;select id=&quot;selectUser&quot; resultMap=&quot;UserResultMap&quot;&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;">select * from user where user_name = #{userName} and dept_id = #{deptId}</span></span>
<span class="line"><span style="color:#A6ACCD;">&lt;/select&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre></div><p><strong>方法3：封装到对象或者Map集合</strong></p><h2 id="foreach表情有哪些属性" tabindex="-1">foreach表情有哪些属性 <a class="header-anchor" href="#foreach表情有哪些属性" aria-hidden="true">#</a></h2><p>使用foreach标签 , foreach的主要用在构建in条件中，它可以在SQL语句中进行迭代一个集合。foreach标签的属性主 要有item，index，collection，open，separator，close。</p><ul><li>collection : 代表要遍历的集合 ,</li><li>item   表示集合中每一个元素进行迭代时的别名，随便起的变量名；</li><li>index   指定一个名字，用于表示在迭代过程中，每次迭代到的位置，不常用；</li><li>open   表示该语句以什么开始</li><li>separator 表示在每次进行迭代之间以什么符号作为分隔符</li><li>close   表示以什么结束</li></ul><p>在使用foreach的时候最关键的也是最容易出错的就是collection属性，该属性是必须指定的，但是 在不同情况下，该属性的值是不一样的，主要有一下3种情况：</p><ol><li><p>如果传入的是单参数且参数类型是一个List的时候，collection属性值为list</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">void findByIds(List&lt;String&gt; ids);</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre></div></li><li><p>如果传入的是单参数且参数类型是一个array数组的时候，collection的属性值为array</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">void findByIds(String ...ids);</span></span>
<span class="line"><span style="color:#A6ACCD;">void findByIds(String[] ids);</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre></div></li><li><p>如果传入的参数是多个的时候，我们就需要把它们封装成一个Map了collection属性值就是传入的List或array对象在自己封 装的map里面的key</p></li></ol><h2 id="如何获取生成的主键" tabindex="-1">如何获取生成的主键 <a class="header-anchor" href="#如何获取生成的主键" aria-hidden="true">#</a></h2><p>新增标签中添加：keyProperty=&quot; ID &quot; 即可</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">&lt;insert id=&quot;insert&quot; useGeneratedKeys=&quot;true&quot; keyProperty=&quot;userId&quot; &gt;</span></span>
<span class="line"><span style="color:#A6ACCD;">	insert into user(user_name, user_password, create_time) values(#{userName}, #{userPassword} , #{createTime})</span></span>
<span class="line"><span style="color:#A6ACCD;">&lt;/insert&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre></div><p>或者配置selectKey</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">&lt;insert id=&quot;insert&quot;  &gt;</span></span>
<span class="line"><span style="color:#A6ACCD;">	&lt;selectKey keyProperty=&quot;userId&quot; resultType=&quot;int&quot; order=&quot;BEFORE&quot;&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;">    	select last_insert_id();</span></span>
<span class="line"><span style="color:#A6ACCD;">  	&lt;/selectKey&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;">	insert into user(user_name, user_password, create_time) values(#{userName}, #{userPassword} , #{createTime})</span></span>
<span class="line"><span style="color:#A6ACCD;">&lt;/insert&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre></div><h2 id="当实体类中的属性名和表中的字段名不一样-怎么办" tabindex="-1">当实体类中的属性名和表中的字段名不一样 ，怎么办 <a class="header-anchor" href="#当实体类中的属性名和表中的字段名不一样-怎么办" aria-hidden="true">#</a></h2><p>第1种： 通过在查询的SQL语句中定义字段名的别名，让字段名的别名和实体类的属性名一致。</p><p>第2种： 通过 来映射字段名和实体类属性名的一一对应的关系。</p><h2 id="使用mybatis的mapper接口调用时有哪些要求" tabindex="-1">使用MyBatis的mapper接口调用时有哪些要求？ <a class="header-anchor" href="#使用mybatis的mapper接口调用时有哪些要求" aria-hidden="true">#</a></h2><ol><li>Mapper接口方法名和mapper.xml中定义的每个sql的id相同。</li><li>Mapper接口方法的输入参数类型和mapper.xml中定义的每个sql 的parameterType的类型相 同。</li><li>Mapper接口方法的输出参数类型和mapper.xml中定义的每个sql的resultType的类型相同。</li><li>Mapper.xml文件中的namespace即是mapper接口的类路径。</li></ol><h2 id="dao接口里的方法-参数不同-时-方法能重载吗" tabindex="-1">Dao接口里的方法，参数不同 时，方法能重载吗 <a class="header-anchor" href="#dao接口里的方法-参数不同-时-方法能重载吗" aria-hidden="true">#</a></h2><p>Dao接口里的方法，是不能重载的，因为是全限名+方法名的保存和寻找策略。</p><h2 id="mybatis动态sql是做什么的-都有哪些动态sql-能简述一下动-态sql的执行原理吗" tabindex="-1">Mybatis动态sql是做什么的？都有哪些动态sql？能简述一下动 态sql的执行原理吗？ <a class="header-anchor" href="#mybatis动态sql是做什么的-都有哪些动态sql-能简述一下动-态sql的执行原理吗" aria-hidden="true">#</a></h2><p>Mybatis动态sql可以让我们在Xml映射文件内，以标签的形式编写动态sql，完成逻辑判断和动态 拼接sql的功能，Mybatis提供了9种动态sql标签 trim|where|set|foreach|if|choose|when|otherwise|bind。</p><p>其执行原理为，使用OGNL从sql参数对象中计算表达式的值，根据表达式的值动态拼接sql，以此 来完成动态sql的功能。</p><h2 id="mybatis是如何进行分页的-分页插件的原理是什么" tabindex="-1">Mybatis是如何进行分页的？分页插件的原理是什么？ <a class="header-anchor" href="#mybatis是如何进行分页的-分页插件的原理是什么" aria-hidden="true">#</a></h2><p>Mybatis使用RowBounds对象进行分页，它是针对ResultSet结果集执行的内存分页，而非物理分 页，可以在sql内直接书写带有物理分页的参数来完成物理分页功能，也可以使用分页插件来完成物理分页。</p><p>分页插件的基本原理是使用Mybatis提供的插件接口，实现自定义插件，在插件的拦截方法内拦截 待执行的sql，然后重写sql，根据dialect方言，添加对应的物理分页语句和物理分页参数。</p><p>举例：select * from student，拦截sql后重写为：select t.* from (select * from student) t limit 0, 10</p><h2 id="简述mybatis的插件运行原理-以及如何编写一个插件。" tabindex="-1">简述Mybatis的插件运行原理，以及如何编写一个插件。 <a class="header-anchor" href="#简述mybatis的插件运行原理-以及如何编写一个插件。" aria-hidden="true">#</a></h2><p>Mybatis仅可以编写针对ParameterHandler、ResultSetHandler、StatementHandler、 Executor这4种接口的插件，Mybatis使用JDK的动态代理，为需要拦截的接口生成代理对象以实现 接口方法拦截功能，每当执行这4种接口对象的方法时，就会进入拦截方法，具体就是 InvocationHandler的invoke()方法，当然，只会拦截那些你指定需要拦截的方法。</p><p>实现Mybatis的Interceptor接口并复写intercept()方法，然后在给插件编写注解，指定要拦截哪一 个接口的哪些方法即可，记住，别忘了在配置文件中配置你编写的插件。</p><h2 id="mybatis的一级、二级缓存" tabindex="-1">Mybatis的一级、二级缓存 <a class="header-anchor" href="#mybatis的一级、二级缓存" aria-hidden="true">#</a></h2><p>一级缓存: 基于 PerpetualCache 的 HashMap 本地缓存，其存储作用域为 Session，当 Session flush 或 close 之后，该 Session 中的所有 Cache 就将清空，默认打开一级缓存</p><p>二级缓存与一级缓存其机制相同，默认也是采用 PerpetualCache，HashMap 存储，不同在于其 存储作用域为 Mapper(Namespace)，并且可自定义存储源，如 Ehcache。默认不打开二级缓 存，要开启二级缓存，使用二级缓存属性类需要实现Serializable序列化接口(可用来保存对象的状 态),可在它的映射文件中配置</p><p>对于缓存数据更新机制，当某一个作用域(一级缓存 Session/二级缓存Namespaces)的进行了 C/U/D 操作后，默认该作用域下所有 select 中的缓存将被 clear</p>`,49),p=[i];function r(o,c,d,h,y,u){return e(),a("div",null,p)}const C=s(n,[["render",r]]);export{b as __pageData,C as default};
