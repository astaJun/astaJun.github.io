import{_ as s,c as a,o as e,b as l}from"./app.2a1337b3.js";const i="/docs/assets/image-20210826170950347-1629968991452-1629968993082.e8acbe47.png",t="/docs/assets/image-20210826171139042.0c621b70.png",n="/docs/assets/image-20210826175727894.19d8d7f1.png",r="/docs/assets/image-20210826175825164-1629971906420.6d5fd06e.png",C=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[{"level":2,"title":"elasticsearch 的倒排索引是什么","slug":"elasticsearch-的倒排索引是什么","link":"#elasticsearch-的倒排索引是什么","children":[]},{"level":2,"title":"什么是分片(SHARDS)","slug":"什么是分片-shards","link":"#什么是分片-shards","children":[]},{"level":2,"title":"什么是副本REPLICAS","slug":"什么是副本replicas","link":"#什么是副本replicas","children":[]},{"level":2,"title":"ElasticSearch中的分词器是什么？","slug":"elasticsearch中的分词器是什么","link":"#elasticsearch中的分词器是什么","children":[]},{"level":2,"title":"你在项目中是如何使用ES的, 主要用到ES哪些功能 ?","slug":"你在项目中是如何使用es的-主要用到es哪些功能","link":"#你在项目中是如何使用es的-主要用到es哪些功能","children":[]},{"level":2,"title":"ElasticSearch常用的查询方式有哪些 ? 如何构建查询条件","slug":"elasticsearch常用的查询方式有哪些-如何构建查询条件","link":"#elasticsearch常用的查询方式有哪些-如何构建查询条件","children":[]},{"level":2,"title":"ElasticSearch如何实现聚合查询","slug":"elasticsearch如何实现聚合查询","link":"#elasticsearch如何实现聚合查询","children":[]},{"level":2,"title":"ElasticSearch如何实现高亮查询","slug":"elasticsearch如何实现高亮查询","link":"#elasticsearch如何实现高亮查询","children":[]},{"level":2,"title":"如果想修改ES中某一个域的类型 , 该如何操作","slug":"如果想修改es中某一个域的类型-该如何操作","link":"#如果想修改es中某一个域的类型-该如何操作","children":[]},{"level":2,"title":"Elasticsearch数据储存在哪里","slug":"elasticsearch数据储存在哪里","link":"#elasticsearch数据储存在哪里","children":[]},{"level":2,"title":"详细描述一下 Elasticsearch 存入数据的过程","slug":"详细描述一下-elasticsearch-存入数据的过程","link":"#详细描述一下-elasticsearch-存入数据的过程","children":[]},{"level":2,"title":"详细描述一下 Elasticsearch 搜索的过程？","slug":"详细描述一下-elasticsearch-搜索的过程","link":"#详细描述一下-elasticsearch-搜索的过程","children":[]},{"level":2,"title":"Elasticsearch 是如何实现 Master 选举的？","slug":"elasticsearch-是如何实现-master-选举的","link":"#elasticsearch-是如何实现-master-选举的","children":[]},{"level":2,"title":"什么是脑裂，Elasticsearch是如何避免脑裂现象的","slug":"什么是脑裂-elasticsearch是如何避免脑裂现象的","link":"#什么是脑裂-elasticsearch是如何避免脑裂现象的","children":[]},{"level":2,"title":"什么是ES路由","slug":"什么是es路由","link":"#什么是es路由","children":[]},{"level":2,"title":"什么是分片与自平衡","slug":"什么是分片与自平衡","link":"#什么是分片与自平衡","children":[]},{"level":2,"title":"在并发情况下，Elasticsearch 如果保证读写一致？","slug":"在并发情况下-elasticsearch-如果保证读写一致","link":"#在并发情况下-elasticsearch-如果保证读写一致","children":[]},{"level":2,"title":"ES调优手段","slug":"es调优手段","link":"#es调优手段","children":[]}],"relativePath":"zh/java/面试/ElasticSearch/ElasticSearch.md","lastUpdated":1675892686000}'),c={name:"zh/java/面试/ElasticSearch/ElasticSearch.md"},p=l('<h2 id="elasticsearch-的倒排索引是什么" tabindex="-1">elasticsearch 的倒排索引是什么 <a class="header-anchor" href="#elasticsearch-的倒排索引是什么" aria-hidden="true">#</a></h2><p>传统的我们的检索是通过文章，逐个遍历找到对应关键词的位置。</p><p>而倒排索引，是通过分词策略，形成了词和文章的映射关系表，这种词典+映射表即为倒排索引。有了 倒排索引，就能实现 o（1）时间复杂度的效率检索文章了，极大的提高了检索效率。</p><p><img src="'+i+`" alt="image-20210826170950347"></p><h2 id="什么是分片-shards" tabindex="-1">什么是分片(SHARDS) <a class="header-anchor" href="#什么是分片-shards" aria-hidden="true">#</a></h2><p>由于应用程序在不同的机器上使用了多个<em>ElasticSearch</em>实例，因此在扩展方面存在诸如RAM、VCPU等资源限制。索引中的数据可以分为多个部分，由一个单独的<em>ElasticSearch</em>节点或实例管理。每个部分称为一个SHARDS。默认情况下，ElasticSearch索引有5个<em>SHARDS</em>。</p><h2 id="什么是副本replicas" tabindex="-1">什么是副本REPLICAS <a class="header-anchor" href="#什么是副本replicas" aria-hidden="true">#</a></h2><p>一个索引被分解成碎片以便于分发和扩展。副本是分片的副本。一个节点是一个属于一个集群的ElasticSearch的运行实例。一个集群由一个或多个共享相同集群名称的节点组成。</p><h2 id="elasticsearch中的分词器是什么" tabindex="-1">ElasticSearch中的分词器是什么？ <a class="header-anchor" href="#elasticsearch中的分词器是什么" aria-hidden="true">#</a></h2><p>在ElasticSearch中索引数据时，数据由为索引定义的Analyzer在内部进行转换。 分析器由一个Tokenizer和零个或多个TokenFilter组成。编译器可以在一个或多个CharFilter之前。分析模块允许您在逻辑名称下注册分析器，然后可以在映射定义或某些API中引用它们。我们主要用的就是IK分词器</p><div class="tip custom-block"><p class="custom-block-title">索引:</p><ol><li>分词 我们 主要 用 的 就是 IK 分词器 ,</li><li>过滤 我们 主要 就是 IK 分词器</li></ol></div><h2 id="你在项目中是如何使用es的-主要用到es哪些功能" tabindex="-1">你在项目中是如何使用ES的, 主要用到ES哪些功能 ? <a class="header-anchor" href="#你在项目中是如何使用es的-主要用到es哪些功能" aria-hidden="true">#</a></h2><p><strong>如何使用的</strong></p><ol><li>使用 spring-data-elasticsearch <ol><li>ElasticSearchTemplate</li><li>基于JPA定义 ElasticSearchRepository</li></ol></li><li>使用ES原生API查询 SearchQueryBuilders</li></ol><p><strong>用到哪些功能</strong></p><ol><li>关键词搜索</li><li>GEO地理位置查询</li></ol><h2 id="elasticsearch常用的查询方式有哪些-如何构建查询条件" tabindex="-1">ElasticSearch常用的查询方式有哪些 ? 如何构建查询条件 <a class="header-anchor" href="#elasticsearch常用的查询方式有哪些-如何构建查询条件" aria-hidden="true">#</a></h2><p><strong>ElasticSearch查询方式有很多 :</strong></p><ol><li>matchAllQuery : 查询所有</li><li>termQuery : 根据关键词查询</li><li>matchQuery : 查询条件分词查询 , 默认取并集 , 可以设置operation 指定取值方式</li><li>wildcard : 模糊查询(不推荐)</li><li>regexpQuery : 正则匹配</li><li>prefixQuery : 前缀查询</li><li>rangeQuery : 范围查询</li><li>queryStringQuery : 查询条件分词查询,可以设置多个检索字段, 默认取并集 , 可以设置operation 指定取值方式</li><li>boolQuery : 多条件组合查询 , must , must_not , shoud , shoud_not , filter</li></ol><p><strong>如何构建查询条件 ?</strong></p><ol><li>使用new关键字创建对应的 SearchQueryBuilders</li><li>使用QueryBuilders进行构建</li></ol><h2 id="elasticsearch如何实现聚合查询" tabindex="-1">ElasticSearch如何实现聚合查询 <a class="header-anchor" href="#elasticsearch如何实现聚合查询" aria-hidden="true">#</a></h2><p>AggregationBuilders构建聚合条件, 使用 aggregation 设置聚合条件</p><blockquote><div class="language-java"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#89DDFF;">    </span><span style="color:#676E95;font-style:italic;">//3. 设置查询条件</span></span>
<span class="line"><span style="color:#A6ACCD;">    sourceBuilder</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">query</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">QueryBuilders</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">matchQuery</span><span style="color:#89DDFF;">(</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">title</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">,</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">手机</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">))</span></span>
<span class="line"><span style="color:#89DDFF;">            </span><span style="color:#676E95;font-style:italic;">//设置桶聚合条件</span></span>
<span class="line"><span style="color:#A6ACCD;">            </span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">aggregation</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">AggregationBuilders</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">terms</span><span style="color:#89DDFF;">(</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">goods_brands</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">).</span><span style="color:#82AAFF;">field</span><span style="color:#89DDFF;">(</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">brandName</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">).</span><span style="color:#82AAFF;">size</span><span style="color:#89DDFF;">(</span><span style="color:#F78C6C;">100</span><span style="color:#89DDFF;">));</span></span>
<span class="line"></span></code></pre></div></blockquote><h2 id="elasticsearch如何实现高亮查询" tabindex="-1">ElasticSearch如何实现高亮查询 <a class="header-anchor" href="#elasticsearch如何实现高亮查询" aria-hidden="true">#</a></h2><p>使用<code>HighlightBuilder </code>设置高亮查询前后缀 , 以及高亮域</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">HighlightBuilder highlightBuilder  =new HighlightBuilder() ;</span></span>
<span class="line"><span style="color:#A6ACCD;">//设置高亮字段</span></span>
<span class="line"><span style="color:#A6ACCD;">highlightBuilder.field(&quot;title&quot;);</span></span>
<span class="line"><span style="color:#A6ACCD;">//设置高亮前缀</span></span>
<span class="line"><span style="color:#A6ACCD;">highlightBuilder.preTags(&quot;&lt;font color=&#39;red&#39;&gt;&quot;);</span></span>
<span class="line"><span style="color:#A6ACCD;">//设置高亮后缀</span></span>
<span class="line"><span style="color:#A6ACCD;">highlightBuilder.postTags(&quot;&lt;/font&gt;&quot;);</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">sourceBuilder.query(QueryBuilders.matchQuery(&quot;title&quot;,&quot;手机&quot;))</span></span>
<span class="line"><span style="color:#A6ACCD;">        .highlighter(highlightBuilder);</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre></div><h2 id="如果想修改es中某一个域的类型-该如何操作" tabindex="-1">如果想修改ES中某一个域的类型 , 该如何操作 <a class="header-anchor" href="#如果想修改es中某一个域的类型-该如何操作" aria-hidden="true">#</a></h2><blockquote><p>注意 : ES中映射创建之后是不允许修改的 , 索引简历之后是不支持改名</p></blockquote><ol><li><p>创建新的索引库</p></li><li><p>将老的索引数据, 保存到新的索引库</p></li></ol><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">POST _reindex</span></span>
<span class="line"><span style="color:#A6ACCD;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">  &quot;source&quot;: {</span></span>
<span class="line"><span style="color:#A6ACCD;"> 	&quot;index&quot;: &quot;goods&quot;</span></span>
<span class="line"><span style="color:#A6ACCD;">  },</span></span>
<span class="line"><span style="color:#A6ACCD;">  &quot;dest&quot;: {</span></span>
<span class="line"><span style="color:#A6ACCD;"> 	&quot;index&quot;: &quot;goods_v2&quot;</span></span>
<span class="line"><span style="color:#A6ACCD;">  }</span></span>
<span class="line"><span style="color:#A6ACCD;">}</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre></div><blockquote><p>这个时候虽然已经可以重新的索引库中查询到数据课 , 但是索引名称变了, 可以使用索引别名解决这个问题</p><ol><li><p>删除原来的索引</p><p>DELETE goods</p></li><li><p>创建索引别名 , 别名为原来的索引名称</p><p>POST goods_v2/_alias/goods</p></li></ol></blockquote><h2 id="elasticsearch数据储存在哪里" tabindex="-1">Elasticsearch数据储存在哪里 <a class="header-anchor" href="#elasticsearch数据储存在哪里" aria-hidden="true">#</a></h2><p><em>ElasticSearch</em>是一个带有多个目录的分布式文档存储。它可以实时存储和检索序列化为JSON文档的复杂数据结构。</p><h2 id="详细描述一下-elasticsearch-存入数据的过程" tabindex="-1">详细描述一下 Elasticsearch 存入数据的过程 <a class="header-anchor" href="#详细描述一下-elasticsearch-存入数据的过程" aria-hidden="true">#</a></h2><p><img src="`+t+'" alt="image-20210826171139042"></p><p>第一步：客户写集群某节点写入数据，发送请求。（如果没有指定路由/协调节点，请求的节点扮演路由节点的角色。）</p><p>第二步：节点 1 接受到请求后，使用文档_id 来确定文档属于分片 0。请求会被转到另外的节点，假定节点 3。因此分片 0 的主分片分配到节点 3 上。</p><blockquote><p>借助路由算法获取，路由算法就是根据路由和文档 id 计算目标的分片 id 的过程。</p></blockquote><p>第三步：节点 3 在主分片上执行写操作，如果成功，则将请求并行转发到节点 1和节点 2 的副本分片 上，等待结果返回。所有的副本分片都报告成功，节点 3 将向协调节点（节点 1）报告成功，节点 1 向 请求客户端报告写入成功。</p><h2 id="详细描述一下-elasticsearch-搜索的过程" tabindex="-1">详细描述一下 Elasticsearch 搜索的过程？ <a class="header-anchor" href="#详细描述一下-elasticsearch-搜索的过程" aria-hidden="true">#</a></h2><p>搜索分为为“query then fetch” 两个阶段。</p><p>query 阶段的目的：定位到位置，但不取。</p><blockquote><ol><li><p>假设一个索引数据有 5 主+1 副本 共 10 分片，一次请求会命中（主或者副本分片中）的一个。</p></li><li><p>每个分片在本地进行查询，结果返回到本地有序的优先队列中。</p></li><li><p>第 2）步骤的结果发送到协调节点，协调节点产生一个全局的排序列表。</p></li></ol></blockquote><p>fetch 阶段的目的：取数据。</p><h2 id="elasticsearch-是如何实现-master-选举的" tabindex="-1">Elasticsearch 是如何实现 Master 选举的？ <a class="header-anchor" href="#elasticsearch-是如何实现-master-选举的" aria-hidden="true">#</a></h2><ol><li><p>Elasticsearch 的选主是 ZenDiscovery 模块负责的，主要包含 Ping（节点之间通过这个 RPC 来发 现彼此）和 Unicast（单播模块包含一个主机列表以控制哪些节点需要 ping 通）这两部分；</p></li><li><p>对所有可以成为 master 的节点（node.master: true）根据 nodeId 字典排序，每次选举每个节 点都把自己所知道节点排一次序，然后选出第一个（第 0 位）节点，暂且认为它是 master 节点。</p></li><li><p>如果对某个节点的投票数达到一定的值（可以成为 master 节点数 n/2+1）并且该节点自己也选 举自己，那这个节点就是 master。否则重新选举一直到满足上述条件。</p><blockquote><p>master 节点的职责主要包括集群、节点和索引的管理，不负责文档级别的管理；data 节 点可以关闭 http 功能</p></blockquote></li></ol><h2 id="什么是脑裂-elasticsearch是如何避免脑裂现象的" tabindex="-1">什么是脑裂，Elasticsearch是如何避免脑裂现象的 <a class="header-anchor" href="#什么是脑裂-elasticsearch是如何避免脑裂现象的" aria-hidden="true">#</a></h2><p>所谓集群脑裂，是指 Elasticsearch 集群中的节点（比如共 8 个），其中的4 个选了一个 master，另外 4 个选了另一个 master 的情况。</p><p><img src="'+n+'" alt="image-20210826175727894"></p><p>当集群 master 候选数量不小于 3 个时，可以通过设置最少投票通过数量（discovery.zen.minimum_master_nodes）超过所有候选节点一半以上来解决脑裂问题； 节点总数量/2 + 1 当候选数量为两个时，只能修改为唯一的一个 master 候选，其他作为 data 节点，避免脑裂问题。</p><h2 id="什么是es路由" tabindex="-1">什么是ES路由 <a class="header-anchor" href="#什么是es路由" aria-hidden="true">#</a></h2><p>文档存入对应的分片，ES计算分片编号的过程，称为路由。</p><p>Elasticsearch 是怎么知道一个文档应该存放到哪个分片中呢？</p><p>查询时，根据文档id查询文档， Elasticsearch 又该去哪个分片中查询数据呢？</p><p>路由算法 ：shard_index = hash(id) % number_of_primary_shards</p><p>例如 : 查询id为5的文档：假如hash(5)=17 ，根据算法17%3=2</p><p><img src="'+r+'" alt="image-20210826175825164"></p><h2 id="什么是分片与自平衡" tabindex="-1">什么是分片与自平衡 <a class="header-anchor" href="#什么是分片与自平衡" aria-hidden="true">#</a></h2><p>当节点挂掉后，挂掉的节点分片会自平衡到其他节点中</p><p>注意：分片数量一旦确定好，不能修改。</p><p><strong>索引分片推荐配置方案：</strong></p><p>1.每个分片推荐大小10-30GB</p><p>2.分片数量推荐 = 节点数量 * 1~3倍</p><p><strong>思考：比如有1000GB数据，应该有多少个分片？多少个节点</strong></p><p>1.每个分片20GB 则可以分为40个分片</p><p>2.分片数量推荐 = 节点数量 * 1~3倍 --&gt; 40/2=20 即20个节点</p><h2 id="在并发情况下-elasticsearch-如果保证读写一致" tabindex="-1">在并发情况下，Elasticsearch 如果保证读写一致？ <a class="header-anchor" href="#在并发情况下-elasticsearch-如果保证读写一致" aria-hidden="true">#</a></h2><ol><li><p>可以通过版本号使用乐观并发控制，以确保新版本不会被旧版本覆盖，由应用层来处理具体的冲 突；</p></li><li><p>另外对于写操作，一致性级别支持 quorum/one/all，默认为 quorum，即只有当大多数分片可用 时才允许写操作。但即使大多数可用，也可能存在因为网络等原因导致写入副本失败，这样该副本被认 为故障，分片将会在一个不同的节点上重建。</p></li><li><p>对于读操作，可以设置 replication 为 sync(默认)，这使得操作在主分片和副本分片都完成后才会 返回；如果设置 replication 为 async 时，也可以通过设置搜索请求参数_preference 为 primary 来查 询主分片，确保文档是最新版本</p></li></ol><h2 id="es调优手段" tabindex="-1">ES调优手段 <a class="header-anchor" href="#es调优手段" aria-hidden="true">#</a></h2><p><strong>设计阶段</strong></p><ol><li>根据业务增量需求，采取基于日期模板创建索引，通过 roll over API 滚动索引；</li><li>使用别名进行索引管理；</li><li>每天凌晨定时对索引做 force_merge 操作，以释放空间；</li><li>采取冷热分离机制，热数据存储到 SSD，提高检索效率；冷数据定期进行 shrink操作，以缩减存 储；</li><li>仅针对需要分词的字段，合理的设置分词器；</li><li>Mapping 阶段充分结合各个字段的属性，是否需要检索、是否需要存储等。</li></ol><p><strong>写入调优</strong></p><ol><li>写入前副本数设置为 0；</li><li>写入前关闭 refresh_interval 设置为-1，禁用刷新机制；</li><li>写入过程中：采取 bulk 批量写入；</li><li>写入后恢复副本数和刷新间隔；</li><li>尽量使用自动生成的 id。</li></ol><p><strong>查询调优</strong></p><ol><li>禁用 wildcard；</li><li>禁用批量 terms（成百上千的场景）；</li><li>充分利用倒排索引机制，能 keyword 类型尽量 keyword；</li><li>数据量大时候，可以先基于时间敲定索引再检索；</li><li>设置合理的路由机制。</li></ol>',76),o=[p];function h(d,u,g,y,D,A){return e(),a("div",null,o)}const E=s(c,[["render",h]]);export{C as __pageData,E as default};
