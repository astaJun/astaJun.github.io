import{_ as e,c as a,o as i,b as r}from"./app.2a1337b3.js";const u=JSON.parse('{"title":"何谓悲观锁与乐观锁","description":"","frontmatter":{},"headers":[{"level":2,"title":"悲观锁","slug":"悲观锁","link":"#悲观锁","children":[]},{"level":2,"title":"乐观锁","slug":"乐观锁","link":"#乐观锁","children":[]},{"level":2,"title":"两种锁的使用场景","slug":"两种锁的使用场景","link":"#两种锁的使用场景","children":[]},{"level":2,"title":"乐观锁常见的两种实现方式","slug":"乐观锁常见的两种实现方式","link":"#乐观锁常见的两种实现方式","children":[{"level":3,"title":"1.版本号机制","slug":"_1-版本号机制","link":"#_1-版本号机制","children":[]}]}],"relativePath":"zh/java/concurrent/pessimistic_lock_and_optimistic_lock.md","lastUpdated":1675460746000}'),n={name:"zh/java/concurrent/pessimistic_lock_and_optimistic_lock.md"},t=r('<h1 id="何谓悲观锁与乐观锁" tabindex="-1">何谓悲观锁与乐观锁 <a class="header-anchor" href="#何谓悲观锁与乐观锁" aria-hidden="true">#</a></h1><p>乐观锁对应于生活中乐观的人总是想着事情往好的方向发展， 悲观锁对应于生 活中悲观的人总是想着事情往坏的方向发展。 这两种人各有优缺点， 不能不以 场景而定说一种人好于另外一种人。</p><h2 id="悲观锁" tabindex="-1">悲观锁 <a class="header-anchor" href="#悲观锁" aria-hidden="true">#</a></h2><p>总是假设最坏的情况， 每次去拿数据的时候都认为别人会修改， 所以每次在拿 数据的时候都会上锁， 这样别人想拿这个数据就会阻塞直到它拿到锁（ 共享资 源每次只给一个线程使用， 其它线程阻塞， 用完后再把资源转让给其它线 程 ） 。 传统的关系型数据库里边就用到了很多这种锁机制， 比如行锁， 表锁 等， 读锁， 写锁等， 都是在做操作之前先上锁。 Java 中 synchronized 和 ReentrantLock 等独占锁就是悲观锁思想的实现。</p><h2 id="乐观锁" tabindex="-1">乐观锁 <a class="header-anchor" href="#乐观锁" aria-hidden="true">#</a></h2><p>总是假设最好的情况， 每次去拿数据的时候都认为别人不会修改， 所以不会上 锁， 但是在更新的时候会判断一下在此期间别人有没有去更新这个数据， 可以 使用版本号机制和 CAS 算法实现。 乐观锁适用于多读的应用类型， 这样可以提 高吞吐量 ， 像数据库提供的类似于 write_condition 机制 ， 其实都是提供的乐 观锁。 在 Java 中 java.util.concurrent.atomic 包下面的原子变量类就是使用了 乐观锁的一种实现方式 CAS 实现的。</p><h2 id="两种锁的使用场景" tabindex="-1">两种锁的使用场景 <a class="header-anchor" href="#两种锁的使用场景" aria-hidden="true">#</a></h2><p>从上面对两种锁的介绍， 我们知道两种锁各有优缺点， 不可认为一种好于另一 种， 像 乐观锁适用于写比较少的情况下（多读场景） ， 即冲突真的很少发生的 时候， 这样可以省去了锁的开销， 加大了系统的整个吞吐量。但如果是多写的 情况， 一般会经常产生冲突， 这就会导致上层应用会不断的进行 retry ， 这样反 倒是降低了性能， 所以 一般多写的场景下用悲观锁就比较合适。</p><h2 id="乐观锁常见的两种实现方式" tabindex="-1">乐观锁常见的两种实现方式 <a class="header-anchor" href="#乐观锁常见的两种实现方式" aria-hidden="true">#</a></h2><p>乐观锁一般会使用版本号机制或 CAS 算法实现。</p><h3 id="_1-版本号机制" tabindex="-1">1.版本号机制 <a class="header-anchor" href="#_1-版本号机制" aria-hidden="true">#</a></h3><p>一般是在数据表中加上一个数据版本号 version 字段， 表示数据被修改的次 数， 当数据被修改时， version 值会加一。 当线程 A 要更新数据值时， 在读取数 据的同时也会读取 version 值， 在提交更新时， 若刚才读取到的 version 值为当 前数据库中的 version 值相等时才更新， 否则重试更新操作， 直到更新成功。 举一个简单的例子： 假设数据库中帐户信息表中有一个 version 字段， 当前值 为 1 ； 而当前帐户余额字段（ balance ） 为 $100 。</p><p>1 . 操作员 A 此时将其读出（ version=1 ） ， 并从其帐户余额中扣除 $50 （ $100-$50 ） 。 2. 在操作员 A 操作的过程中， 操作员 B 也读入此用户信息（ version=1 ） ， 并从其帐户余额中扣除 $20 （ $100-$20 ） 。 3. 操作员 A 完成了修改工作， 将数据版本号加一（ version=2 ） ， 连同 帐户扣除后余额（ balance=$50 ） ， 提交至数据库更新， 此时由于提 交数据版本大于数据库记录当前版本， 数据被更新， 数据库记录 version 更新为 2 。 4. 操作员 B 完成了操作， 也将版本号加一（ version=2 ） 试图向数据库 提交数据（ balance=$80 ） ， 但此时比对数据库记录版本时发现， 操 作员 B 提交的数据版本号为 2 ， 数据库记录当前版本也为 2 ， 不满 足 “ 提交版本必须大于记录当前版本才能执行更新 “ 的乐观锁策略， 因此， 操作员 B 的提交被驳回。</p>',13),s=[t];function c(o,l,d,h,_,p){return i(),a("div",null,s)}const m=e(n,[["render",c]]);export{u as __pageData,m as default};
