# hashmap在1.8中做了那些优化

在java1.7中，HashMap的数据结构为数组+单向链表。java1.8中变成数组+单向链表+红黑树

链表插入节点的方式

在java1.7中，插入链表节点使用头插法。java1.8变成尾查法

hash函数

java1.8的hash()中。将hash值高位(前16位)参与到取模的运算中，使得计算结果的不确定性增强，降低发生哈希碰撞的概率

**扩容优化**：

扩容以后1.7对元素进行rehash算法，计算原来每个元素在扩容之后的哈希表中的位置1.8借助2倍扩容机制，元素不需要进行重新计算位置

JDK1.8在扩容并没有像JDK1.7那样，重新计算每个元素的哈希值，而是通过高位运算(e.hash & oldCap)来确定元素是否需要移动，比如 key1 的信息如下：

![](E:/Git/hexo/source/_posts/JavaSE/1.png)

使用 e.hash & oldCap 得到的结果，高一位为0，当结果为0时表示元素在扩容时位置不会发生任何变化，而 key2信息如下

![](E:/Git/hexo/source/_posts/JavaSE/2.png)

![](E:/Git/hexo/source/_posts/JavaSE/3.png)

高一位为 1，当结果为 1 时，表示元素在扩容时位置发生了变化，新的下标位置等于原下标位置 + 原数组长度 **hashmap，不必像1.7一样全部重新计算位置**